#!/bin/sh

# redirect stdout/stderr from this script to a log file
exec >> "$HOME/.xlog" 2>&1

# if xhost (from x11-xserver-utils) is installed, use it to give access
# to the X server to any process from the same user on the local host.
# unlike other uses of xhost, this is safe since the kernel can check
# the actual owner of the calling process.
if command -v xhost >/dev/null 2>&1; then
    xhost "+si:localuser:$(id -un)" || :
fi

# if no argument was passed, try and guess what command to start x with
if [ -z "$*" ]; then
    if command -v 'x-session-manager' >/dev/null 2>&1; then
        X_START_CMD='x-session-manager'
    elif command -v 'x-window-manager' >/dev/null 2>&1; then
        X_START_CMD='x-window-manager'
    elif command -v 'i3' >/dev/null 2>&1; then
        X_START_CMD='i3'
    else
        echo "No appropriate X start command found!"
        exit 1
    fi
else
    X_START_CMD="$*"
fi

# Debian quirks
if [ "$(lsb_release -is)" = 'Debian' ]; then
    # use dbus-launch to spawn the session if available. this enables X
    # applications to talk to dbus because it spawns a dbus session and sets
    # some environment variables (I think?)
    if command -v 'dbus-launch' >/dev/null 2>&1; then
        X_START_CMD="dbus-launch --exit-with-session $X_START_CMD"
    fi
fi

# normally you'd prepend ssh-agent to X_START_CMD, which would set all the
# environment variables and make the agent quit when X quits, but because a
# program started from this script (xautolock/xidlehook) needs access to the
# ssh-agent environment variables, use this somewhat nasty hack instead.
# TODO: find alternative solutions
if command -v 'ssh-agent' >/dev/null 2>&1; then
    ssh-agent -k
    eval "$(ssh-agent -s)"
fi

# configure external monitors
if [ -x $HOME/.xrandrinit ]; then
    $HOME/.xrandrinit
else
    # this normally happens in xrandrinit, but if it does not exist, do it here
    if [ -x $HOME/.fehbg ]; then
        $HOME/.fehbg &
    fi
fi

# checks if a command exist, and that it's not already running
check_cmd() {
    command -v $1 >/dev/null 2>&1 && ! pidof $1 >/dev/null
}

# displays simple notifications
if check_cmd dunst; then
    dunst &
fi

# xflux/redshift change the screen's color when night time comes around
if check_cmd redshift; then
    redshift -t 6500:2900 &
fi

# compton is a composition manager, allowing window transparency.
# if there's no desktop background, there's no point in running it.
if [ -x $HOME/.fehbg ] && check_cmd compton; then
    compton -b &
fi

# dropbox should be self-explanatory
if check_cmd dropbox; then
    dropbox start &
fi

# network-manager applet, puts a network icon in the tray
if check_cmd nm-applet; then
    nm-applet &
fi

# unclutter removes the mouse cursor after a given amount of idle time
if check_cmd unclutter; then
    unclutter -idle 3 -root &
fi

# auto lock/suspend after inactivity
# if command -v xidlehook >/dev/null 2>&1; then
#     xidlehook --not-when-fullscreen --not-when-audio --timer 300 'lockscreen' '' --timer 1800 'lockscreen --suspend' '' &
# elif command -v xautolock >/dev/null 2>&1; then
#     if acpi -b 2> /dev/null | grep -q Battery; then
#         xautolock -time 60 -corners 000- -cornersize 30 -detectsleep -locker 'lockscreen --suspend' &
#     else
#         xautolock -time 5 -locker 'lockscreen' &
#     fi
# fi

# I want to be able to re-run commands that set settings like mouse sensitivity,
# keyboard repeat rate etc., so split that up into its own file
if [ -x $HOME/.xsettings ]; then
    . $HOME/.xsettings
fi

# start the window manager. this is a blocking command. normally you'd want to
# exec this, but that would prevent the cleanup commands below from running
$X_START_CMD

# when the window manager command quits, we can also kill the ssh-agent
if command -v 'ssh-agent' >/dev/null 2>&1; then
    ssh-agent -k
fi

# kill the gpg-agent if it's running
if command -v gpgconf >/dev/null 2>&1; then
    gpgconf --kill gpg-agent
fi
